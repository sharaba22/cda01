# მავნე პროგრამების ამოცნობა ბინარული-დან-სურათზე გარდაქმნითა და CNN-ით — დოკუმენტაცია (KA)

## მიმოხილვა
ეს პროგრამა ახდენს ბინარული ფაილების (მაგ., `.exe`, `.bin`) ან სურათებად უკვე გარდაქმნილი ფაილების კლასიფიკაციას ორ კლასში — **malware (1)** და **benign (0)**. შესრულებადი ფაილები გარდაიქმნება შავთეთრ (გრადიენტულ) სურათად (0–255), ზომები დგება ფიქსირებულ ნიშნულზე და სწავლისათვის გამოიყენება მარტივი **Convolutional Neural Network (CNN)**. პროგრამა ასევე ქმნის **Grad-CAM** სითბურ რუკას მოდელის განმარტებადობისთვის.

## პროექტის სტრუქტურა და წინაპირობები
- **Python პაკეტები:** `numpy`, `pillow`, `matplotlib`, `tensorflow (keras)`, `scikit-learn`  
- **საქაღალდე:** `malware_dataset/` ორი ქვესაქაღალდით:
  - `malware_dataset/malware/` — მავნე ნიმუშების სურათები ან ბინარები
  - `malware_dataset/benign/` — კეთილგანწყობილი ნიმუშების სურათები ან ბინარები  
- **კონფიგურაცია კოდში:**
  - `DATA_DIR = "./malware_dataset"`
  - `IMG_SIZE = 128` (შეიძლება 64/96/128/224…)
  - `MAX_FILES = None` (იცვლება მცირე ტესტებისთვის)

> შენიშვნა: თუ მონაცემები უკვე სურათებია (PNG/JPG), კოდი პირდაპირ წაიკითხავს მათ. თუ ბინარებია, გარდაქმნის სურათად ფუნქციით `bytes_to_image`.

## სამუშაო ნაკადი
1. **ბინარიდან სურათამდე:** `bytes_to_image` ბაიტების მასივს აწყობს კვადრატულ მატრიცად და აცურებს ზომაზე `IMG_SIZE×IMG_SIZE` (გრეისკეილ `"L"`).
2. **დატასეტის აგება:** მოიძიება ფაილები `benign/` და `malware/` ქვეკატალოგებში; შედეგი ინახება `X` (N×H×W×1) და `y` მასივებში.
3. **ნორმალიზაცია:** `X / 255.0` და არხის დამატება `[..., np.newaxis]`.
4. **გაყოფა:** `train_test_split(..., stratify=y)` 80/20 პროპორციით.
5. **CNN არქიტექტურა:** 3× (Conv+MaxPool) ბლოკი, შემდეგ `Flatten → Dense(128) → Dense(1, sigmoid)`.
6. **ტრენინგი:** `model.fit(..., epochs=5, batch_size=32)`.
7. **შეფასება:** `classification_report`, `confusion_matrix`, ასევე ნიმუშების ვიზუალიზაცია(probabilities).
8. **Grad-CAM:** ბოლო Conv ფენის აქტივაციებით და პროგნოზზე გრადიენტებით ფორმირდება სითბური რუკა.

## Grad-CAM — თავსებადი ვერსია (Keras 2/3)
Keras 3-ში ზოგჯერ ჩნდება შეცდომა `"The layer sequential has never been called..."`. დოკში გამოყენებულია გამძლე ვერსია:
- ავტო-ამოცნობა ბოლო `Conv2D` ფენისთვის;
- `ensure_built()` — ერთხელ მაინც აკეთებს `predict`, რათა განსაზღვრდეს `inputs/outputs`;
- `grad_model([img_tensor], training=False)` — `inputs` სტრუქტურის მკაცრი შესაბამისობა.

თუ მიიღებთ გაფრთხილებას `"The structure of inputs..."`, ეს მხოლოდ warning-ია; ჩვენს კოდში ისიც აღმოფხვრილია `list`-ად გადაცემით.

## რჩევები მცირე სივრცისთვის
- გამოიყენეთ **წინასწარ გარდაქმნილი სურათები** (PNG/JPG) — ბინარული არქივების ნაცვლად.
- შეამცირეთ სურათების რეზოლუცია (`IMG_SIZE=64/96`).
- შეზღუდეთ ნიმუშების რაოდენობა კლასზე (მაგ., 100–300).
- თუ Kaggle-ზე ქმნით ქვეკომპლექტს, აიღეთ ბალანსირებული შერჩევა (მაგ., 200 benign / 200 malware).

## ტიპური პრობლემები და გადაწყვეტა
- **Grad-CAM შეცდომა (Keras 3):** გამოიყენეთ დოკში მოცემული გაძლიერებული ფუნქცია.
- **ანომალური კლასბალანსი:** გამოიყენეთ `class_weight` ან oversampling.
- **IO შეცდომები:** დაზიანებული ფაილები გამოტოვეთ (`file_to_image` უკვე იჭერს გამონაკლისს).
- **Download პრობლემები Kaggle-ში:** შეინახეთ „Save Version → Output files“ და იქიდან ჩამოიწერეთ ZIP.

## გაშვება
1. მოამზადეთ `malware_dataset/benign` და `malware_dataset/malware` სურათებით.
2. დაარანქეთ ნოუთბუქი ან სქრიპტი (`python malware_notebook.py`).
3. ნახეთ ბრძანებით დაბეჭდილი მეტრიკები და სურათები; ბოლოს — Grad-CAM ჰითმეფი.
