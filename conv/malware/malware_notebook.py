# Malware Detection with CNN — Notebook (Python)
# -----------------------------------------------
# This notebook demonstrates a realistic workflow for malware classification
# using binary-to-image conversion and a CNN classifier.
#
# Steps:
# 1) Prepare a dataset folder with two subfolders: "benign" and "malware".
#    Each subfolder contains binary files (.exe, .bin, etc.) or already-converted images.
# 2) The code converts binaries to grayscale images (byte values 0-255),
#    resizes/pads them to a fixed size, and builds train/val datasets.
# 3) Trains a small CNN on the images (binary classification).
# 4) Shows example predictions and a Grad-CAM explanation heatmap for interpretability.
#
# Requirements: numpy, pandas, pillow, matplotlib, tensorflow, sklearn
# Usage: Update DATA_DIR to point to your dataset and run cells.

import os
import math
import numpy as np
from glob import glob
from PIL import Image
import matplotlib.pyplot as plt
import random
import tensorflow as tf
from tensorflow.keras import layers, models
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix

# -----------------------
# Config (change paths)
# -----------------------
DATA_DIR = "./malware_dataset"  # should contain 'benign' and 'malware' subfolders
IMG_SIZE = 128                  # final square image size (128x128 recommended)
MAX_FILES = None                # set to None or integer to limit files per class for quick runs
RANDOM_SEED = 42

# -----------------------
# Helpers: binary -> image
# -----------------------
def bytes_to_image(byte_arr, size=IMG_SIZE):
    # Convert 1D byte array into 2D image by reshaping into near-square and resizing
    length = len(byte_arr)
    if length == 0:
        return Image.new('L', (size, size))  # empty image
    # compute minimal square side or choose fixed width strategy
    side = int(math.ceil(math.sqrt(length)))
    # pad to side*side
    padded = np.zeros(side*side, dtype=np.uint8)
    padded[:length] = np.frombuffer(byte_arr, dtype=np.uint8)
    arr2d = padded.reshape((side, side))
    img = Image.fromarray(arr2d, mode='L')  # grayscale
    img = img.resize((size, size), resample=Image.BILINEAR)
    return img

def file_to_image(path, size=IMG_SIZE):
    try:
        with open(path, 'rb') as f:
            data = f.read()
        img = bytes_to_image(data, size=size)
        return np.array(img, dtype=np.uint8)
    except Exception as e:
        print("Failed to convert", path, ":", e)
        return None

# -----------------------
# 1) Collect files & labels
# -----------------------
classes = ['benign', 'malware']
filepaths = []
labels = []
for i, cls in enumerate(classes):
    folder = os.path.join(DATA_DIR, cls)
    if not os.path.isdir(folder):
        raise FileNotFoundError(f"Expected folder: {folder}")
    files = glob(os.path.join(folder, '*'))
    if MAX_FILES:
        files = files[:MAX_FILES]
    filepaths.extend(files)
    labels.extend([i]*len(files))

print("Found files:", len(filepaths))
random.seed(RANDOM_SEED)
combined = list(zip(filepaths, labels))
random.shuffle(combined)
filepaths, labels = zip(*combined)

# -----------------------
# 2) Convert to images (may take time)
# -----------------------
X = []
y = []
for fp, lab in zip(filepaths, labels):
    img_arr = file_to_image(fp, size=IMG_SIZE)
    if img_arr is None:
        continue
    X.append(img_arr)
    y.append(lab)
X = np.stack(X, axis=0)
y = np.array(y)
print("Built dataset images:", X.shape, y.sum(), "malware samples")

# Normalize and expand channel
X = X.astype('float32') / 255.0
X = X[..., np.newaxis]

# -----------------------
# 3) Train/validation split
# -----------------------
X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, stratify=y, random_state=RANDOM_SEED)
print("Train:", X_train.shape, "Val:", X_val.shape)

# -----------------------
# 4) Simple CNN model
# -----------------------
model = models.Sequential([
    layers.Input(shape=(IMG_SIZE, IMG_SIZE, 1)),
    layers.Conv2D(32, (3,3), activation='relu', padding='same'),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(64, (3,3), activation='relu', padding='same'),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(128, (3,3), activation='relu', padding='same'),
    layers.MaxPooling2D((2,2)),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(1, activation='sigmoid')
])
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
model.summary()

# -----------------------
# 5) Train (few epochs by default)
# -----------------------
history = model.fit(X_train, y_train, epochs=20, batch_size=32, validation_data=(X_val, y_val))

# -----------------------
# 6) Evaluate & show examples
# -----------------------
print(classification_report(y_val, (model.predict(X_val).ravel() > 0.5).astype(int), digits=4))
cm = confusion_matrix(y_val, (model.predict(X_val).ravel() > 0.5).astype(int))
print("Confusion matrix:\n", cm)

# Show sample images with predictions
probs = model.predict(X_val).ravel()
idxs = np.argsort(-probs)[:8]
plt.figure(figsize=(12,6))
for i, idx in enumerate(idxs):
    plt.subplot(2,4,i+1)
    plt.imshow(X_val[idx,...,0], cmap='gray'); plt.axis('off')
    plt.title(f"p={probs[idx]:.2f}, y={y_val[idx]}")
plt.suptitle("Top predicted malware samples (val)")
plt.show()

# -----------------------
# 7) Grad-CAM explanation (example for one image) (robust for Keras 2/3)
# -----------------------
import tensorflow as tf
from tensorflow.keras import layers

def get_last_conv_layer(m):
    # იპოვე ბოლო Conv2D ფენა ავტომატურად (სახელზე არ ვიყრით გულს)
    for layer in reversed(m.layers):
        if isinstance(layer, layers.Conv2D):
            return layer
    raise ValueError("Conv2D layer not found in model.")

def ensure_built(m, sample_shape=(1, 128, 128, 1)):
    # ზოგ ვერსიაში საჭიროა ერთხელ მაინც გამოიძახო forward pass,
    # რომ model.outputs და model.inputs სწორად განისაზღვროს
    try:
        _ = m.outputs  # ცდილობს წვდომას
    except Exception:
        import numpy as np
        _ = m.predict(np.zeros(sample_shape, dtype="float32"), verbose=0)

def make_gradcam_heatmap(img_array, model):
    """
    img_array: (1, H, W, C) normalized
    """
    # დაემყარო, რომ მოდელი "დახმობილია" და აქვს outputs/inputs
    ensure_built(model, sample_shape=img_array.shape)

    last_conv = get_last_conv_layer(model)

    # Keras 2/3 თავსებადი inputs/outputs
    model_inputs  = model.inputs if hasattr(model, "inputs") else model.input
    model_outputs = model.outputs[0] if hasattr(model, "outputs") else model.output

    # მოდელი, რომელიც აბრუნებს ბოლო კონვ-ის აქტივაციას და საბოლოო პროგნოზს
    grad_model = tf.keras.models.Model(
        inputs=model_inputs,
        outputs=[last_conv.output, model_outputs]
    )

    with tf.GradientTape() as tape:
        img_array = tf.convert_to_tensor(img_array, dtype=tf.float32)
        conv_outputs, predictions = grad_model([img_array], training=False)
        # ბინარული კლასიფიკაციაა → ვიღებთ პოზიტიურ ლოგიტს/პრობლს
        loss = predictions[:, 0]

    grads = tape.gradient(loss, conv_outputs)
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))
    conv_outputs = conv_outputs[0]

    heatmap = tf.reduce_sum(conv_outputs * pooled_grads, axis=-1)
    heatmap = tf.maximum(heatmap, 0) / (tf.reduce_max(heatmap) + 1e-8)
    return heatmap.numpy()

# --- გამოყენება ---
# დარწმუნდი, რომ sample_img არის (1,H,W,C)
# მოკლე "თბილი გაშვება", რომ Sequential "დაებილდოს" (ზოგ ვერსიას სჭირდება)
_ = model.predict(X_val[:1], verbose=0)

# აირჩიე ყველაზე მაღალი ალბათობის ნიმუში, როგორც ადრე
probs = model.predict(X_val, verbose=0).ravel()
idxs = np.argsort(-probs)[:8]
sample_idx = idxs[0]
sample_img = X_val[sample_idx:sample_idx+1]

heatmap = make_gradcam_heatmap(sample_img, model)

plt.figure(figsize=(6,6))
plt.imshow(X_val[sample_idx, ..., 0], cmap='gray')
plt.imshow(heatmap, cmap='jet', alpha=0.4, extent=(0, IMG_SIZE, 0, IMG_SIZE), origin='lower')
plt.title(f"Grad-CAM overlay (p={probs[sample_idx]:.2f})")
plt.axis('off')
plt.show()


print("Notebook finished. Adjust DATA_DIR and IMG_SIZE as needed.")