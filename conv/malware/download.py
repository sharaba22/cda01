import os, random, shutil, glob, zipfile, math

random.seed(42)

# აქაა Kaggle-ზე dataset-ის დამაუნთებული შიგთავსი
SRC = "/kaggle/input/malware-images"   # თუ სხვაა, ჩაასწორე
OUT = "/kaggle/working/subset"

# პარამეტრები — მცირე ZIP-ისთვის
MAX_PER_CLASS = 200             # მაქს. ნიმუში თითო კლასზე
ALLOW_EXT = (".png", ".jpg", ".jpeg", ".bmp")  # სურათების გაფ.ები

# რომელი სახელები ჩაითვალოს benign-ად (ქეის-ინსენსიტივი)
BENIGN_HINTS = ("benign", "goodware", "nonmalware", "clean", "safe")

os.makedirs(f"{OUT}/malware", exist_ok=True)
os.makedirs(f"{OUT}/benign",  exist_ok=True)

def list_images(root):
    return [p for p in glob.glob(f"{root}/**/*", recursive=True)
            if os.path.splitext(p)[1].lower() in ALLOW_EXT]

all_imgs = list_images(SRC)

# გამოვყოთ benign ფაილები — თუ ბილიკში/საქაღალდეში ჩანს მინიშნებები
benign_files = [p for p in all_imgs if any(h in p.lower() for h in BENIGN_HINTS)]
# დანარჩენი — malware
malware_files = [p for p in all_imgs if p not in benign_files]

print(f"  images found: {len(all_imgs)}")
print(f"  benign candidates: {len(benign_files)}")
print(f"  malware candidates: {len(malware_files)}")

# შეზღუდული, ბალანსირებული შერჩევა
take_benign = min(MAX_PER_CLASS, len(benign_files))
take_mal    = min(MAX_PER_CLASS, len(malware_files))

random.shuffle(benign_files); random.shuffle(malware_files)
benign_pick = benign_files[:take_benign]
malware_pick= malware_files[:take_mal]

# კოპირება (შენარჩუნდეს mtime/metadata -> copy2)
for src in benign_pick:
    shutil.copy2(src, f"{OUT}/benign/{os.path.basename(src)}")
for src in malware_pick:
    shutil.copy2(src, f"{OUT}/malware/{os.path.basename(src)}")

print(f"Copied: benign={len(benign_pick)}, malware={len(malware_pick)}")

# პატარა „ლაბელები“ სამომავლოდ (არ არის სავალდებულო)
with open(f"{OUT}/labels.txt", "w", encoding="utf-8") as f:
    for p in sorted(glob.glob(f"{OUT}/benign/*")):
        f.write(f"{os.path.basename(p)}\t0\n")
    for p in sorted(glob.glob(f"{OUT}/malware/*")):
        f.write(f"{os.path.basename(p)}\t1\n")

# შეკვრა ZIP-ად
zip_path = "/kaggle/working/malware_subset.zip"
with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as z:
    for folder in ("benign", "malware",):
        for p in glob.glob(f"{OUT}/{folder}/*"):
            z.write(p, arcname=os.path.relpath(p, OUT))
    z.write(f"{OUT}/labels.txt", arcname="labels.txt")

# ზომის მონახაზი
zip_size_mb = os.path.getsize(zip_path) / (1024*1024)
print(f"DONE: {zip_path}  (~{zip_size_mb:.1f} MB)")
